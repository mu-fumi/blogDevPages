{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{156:function(e,t,n){e.exports=n.p+\"assets/img/asco.6c5bc24e.png\"},161:function(e,t,n){\"use strict\";n.r(t);var r=[function(){var e=this,t=e.$createElement,r=e._self._c||t;return r(\"div\",{staticClass:\"content\"},[r(\"h1\",{attrs:{id:\"跨域\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#跨域\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 跨域\")]),r(\"h3\",{attrs:{id:\"跨域是什么？\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#跨域是什么？\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),r(\"em\",[e._v(\"跨域是什么？\")])]),r(\"pre\",[r(\"code\",[e._v(\"\\t在浏览器需要执行其他网站的脚本或者在其他网站请求数据，但是由于浏览器的同源策略存在，所以产生了跨域。\\n\")])]),r(\"p\",[e._v(\"同源策略：\\n浏览器规定了如果两个 url 的\"),r(\"strong\",[e._v(\"协议\")]),e._v(\"、\"),r(\"strong\",[e._v(\"域名\")]),e._v(\"、\"),r(\"strong\",[e._v(\"端口\")]),e._v(\"中有任何一个不等，就认定它们跨源了。\")]),r(\"p\",[r(\"img\",{attrs:{src:n(156),alt:\"Alt text\"}})]),r(\"p\",[e._v(\"当浏览器认定你跨源后，你将：\")]),r(\"pre\",[r(\"code\",[e._v(\"不能获取Cookie、LocalStorage、IndexedDB；\\n不能获取 dom 节点；\\n不能进行一般的 Ajax 通信；\\n\")])]),r(\"p\",[e._v(\"所以这时我们就需要跨域了。通用的几种跨域方法\")]),r(\"h5\",{attrs:{id:\"_1-jsonp-跨域\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-jsonp-跨域\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 1 . JSONP 跨域\")]),r(\"p\",[e._v(\"利用 script 标签，和 img 标签。（这些标签是不受同源策略限制的）JSONP 的核心就是通过动态加载 script 标签和img 标签的src属性，\\n来完成对目标 url 的请求。\\n但由于标签的性质，只支持GET请求\\n例：\")]),r(\"pre\",[r(\"code\",[e._v(\"function handleResponse(res) {\\n   // 回调函数，处理返回到的数据\\n}\\nconst script = document.createElement('script')\\nscript.src = 'http://127.0.0.1:3000?callback=handleResponse'\\ndocument.head.appendChild(script)\\n\")])]),r(\"h5\",{attrs:{id:\"_2-cors-跨域\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-cors-跨域\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 2 . CORS 跨域\")]),r(\"p\",[e._v(\"CORS( \"),r(\"strong\",[e._v(\"Cross-Origin Resource Sharing\")]),e._v(\" )，这种跨域较为常见，\\n具体就是：\")]),r(\"pre\",[r(\"code\",[e._v(\"当前端与后端进行 Ajax 通信时，通过自定义 HTTP 头部设置从而决定请求或响应是否生效\\n\")])]),r(\"p\",[e._v(\"例如：（本url 为  \"),r(\"code\",[e._v(\"http://localhost:3001\")]),e._v(\"）\")]),r(\"pre\",[r(\"code\",[e._v(\"const xhr = new XMLHttpRequest()\\nxhr.onreadystatechange = function () {\\n  if (xhr.readyState === 4) {\\n    if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {\\n      console.log('res:' + xhr.responseText)\\n    }\\n  }\\n}\\nxhr.open('get', 'http://localhost:3000', true)\\nxhr.send()\\n\")])]),r(\"p\",[e._v(\"在浏览器发送请求的时候就会多出一行代码\")]),r(\"pre\",[r(\"code\",[e._v(\"Origin: http://localhost:3001\\n\")])]),r(\"p\",[e._v(\"但是在控制台依旧会报错\")]),r(\"pre\",[r(\"code\",[e._v(\" 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://localhost:3001' is therefore not allowed access.\\n\")])]),r(\"p\",[e._v(\"这时我们需要在后台设置 'Access-Control-Allow-Origin' 这个字段，它的作用就是设置允许来自什么源的请求，\")]),r(\"p\",[e._v(\"同时cors  还支持put,delete 等预请求。详见 \"),r(\"a\",{attrs:{href:\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"CORS\")])]),r(\"h5\",{attrs:{id:\"_3-代理\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-代理\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 3 . 代理\")]),r(\"p\",[e._v(\"浏览器存在跨域的问题，但服务器不存在这个问题的，所以我们可以配置服务器，来达到跨域的目的\")]),r(\"p\",[e._v(\"例如：源址 \"),r(\"code\",[e._v(\"www.123.com/index.html\")])]),r(\"pre\",[r(\"code\",[e._v(\"为了数据，需要调用www.456.com/server.php这个接口，\\n这时后台可以写一个接口www.123.com/server.php，\\n由这个接口在后端去调用www.456.com/server.php并拿到返回值，\\n然后再返回给index.html。\\n\")])]),r(\"p\",[e._v(\"这就是一个代理的模式。相当于绕过了浏览器端，自然就不存在跨域问题。\")]),r(\"h5\",{attrs:{id:\"_4-websockets\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-websockets\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 4 . WebSockets\")]),r(\"p\",[e._v(\"WebSockets 属于 HTML5 的协议，它的目的是在一个持久连接上建立全双工通信。由于 WebSockets 采用了自定义协议，所以优点是客户端和服务端发送数据量少，缺点是要额外的服务器。基础的使用方法如下：\")]),r(\"pre\",[r(\"code\",[e._v(\"const ws = new WebSocket('ws://127.0.0.1:3000')\\nws.onopen = function() {\\n  // 连接成功建立\\n}\\n\\nws.onmessage = function(event) {\\n  // 处理数据\\n}\\n\\nws.onerror = function() {\\n  // 发生错误时触发，连接中断\\n}\\n\\nws.onclose = function() {\\n  // 连接关闭时触发\\n}\\n\")])]),r(\"p\",[e._v(\"也可以使用封装好的库    socket.io\")])])}],s=n(1),o=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},r,!1,null,null,null);t.default=o.exports}}]);","extractedComments":[]}